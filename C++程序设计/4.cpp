#include <iostream>
#include <stdio.h> 
using namespace std;

/*
位运算:用于对整数类型(int,char,long等)变量中的
某一位(bit),或者若干位进行操作。比如：
1) 判断某一位是否为1
2) 只改变其中某一位，而保持其它位都不变

c/c++语言提供了六种位运算符来进行位运算操作：
&  按位与(双目)
|  按位或(双目)
^  按位异或(双目)
~  按位非(取反)(单目)
<< 左移(双目)
>> 右移(双目)

异或 只有对应德两个二进位不相同时，结果的对应二进制才是1，否则为0
异或 a^b=c,那么就有c^b=a以及c^a=b, 此规律可以用来进行最简单的加密和解密
异或 另外异或运算还能实现不通过临时变量，就能交换两个变量的值
int a = 5, b = 7;
a = a ^ b;
b = b ^ a;
a = a ^ b;
即实现a,b值交换。穷举法可证。

左移运算符"<<"
表达式:
a << b
的值是:将a各二进制全部左移b位后得到的值。左移时，高位丢弃，低位补0。a的值不因运算而改变
实际上，左移1位，就等于是乘以2，左移n位，就等于是乘以2的n次方。而左移操作比乘法操作快的多 

右移运算符">>"
表达式:
a >> b
的值是:将a各二进位全部右移b位后得到的值。右移时，移出最右边的位就被丢弃。a的值不因运算而改变。 
对于有符号数，如long, int, short, char类型变量，在右移时，符号位(即最高位)将一起移动， 
并且大多数c/c++编译器规定，如果原符号位为1，则右移时高位就补充1，原符号位为0，则右移时高位就补充0 
实际上，右移n位，就相当于左操作数除以2的n次方，并且将结果往小里取整。
 -25 >> 4 = -2
 -2 >> 4 = -1
 18 >> 4 = 1
*/ 
int main()
{
	int n1 = 15;
	short n2 = -15;
	unsigned short n3 = 0xffe0;
	char c = 15;
	n1 = n1 >> 2;
	n2 >>= 3;
	n3 >>= 4;
	c >>= 3;
	printf("n1=%d, n2=%x, n3=%x, c=%x", n1, n2, n3, c);
}

